<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HNSW æ·±åº¦æ˜¾å¾®é•œ (Step-by-Step EF)</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, monospace;
      display: grid; grid-template-columns: 320px 1fr; height: 100vh;
      background: #fbfbfb; overflow: hidden;
    }
    #panel {
      padding: 14px; border-right: 1px solid rgba(0,0,0,0.1);
      background: #fff; overflow-y: auto; display: flex; flex-direction: column; gap: 10px;
      box-shadow: 2px 0 10px rgba(0,0,0,0.02); z-index: 2;
    }
    h2 { margin: 0; font-size: 16px; color: #333; }
    .btns { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 5px; }
    button {
      flex: 1; padding: 8px; border-radius: 6px; border: 1px solid #ccc;
      background: #f4f4f4; cursor: pointer; font-size: 12px; color: #333;
      transition: all 0.1s; font-weight: 500;
    }
    button:hover { background: #e0e0e0; border-color: #999; }
    button:active { transform: translateY(1px); }
    button.primary { background: #333; color: #fff; border-color: #000; }
    button.primary:hover { background: #555; }

    .row { display: flex; justify-content: space-between; align-items: center; font-size: 12px; }
    .row input[type="number"] { width: 60px; padding: 3px; }
    .row input[type="range"] { flex:1; margin-left:10px; }

    #statePanel {
      margin-top: auto; padding: 10px; background: #f0f0f5; 
      border-radius: 6px; font-size: 11px; font-family: monospace;
      border: 1px solid #ddd; min-height: 120px;
    }
    .tag { display: inline-block; padding: 1px 4px; border-radius: 3px; margin-right: 4px; color: #fff; }
    .tag.curr { background: #007bff; }
    .tag.cand { background: #28a745; }
    .tag.check { background: #ffc107; color: #333; }

    #wrap { position: relative; background: #f4f4f4; overflow: hidden; }
    svg { width: 100%; height: 100%; display: block; }
    
    #overlayInfo {
      position: absolute; top: 10px; left: 10px; 
      background: rgba(255,255,255,0.95); padding: 8px 12px; 
      border-radius: 6px; border: 1px solid rgba(0,0,0,0.1);
      font-size: 12px; font-family: monospace; pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 300px;
    }
    .log-line { margin: 2px 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  </style>
</head>
<body>
  <div id="panel">
    <h2>HNSW æ·±åº¦æ˜¾å¾®é•œ</h2>
    
    <div style="font-size:12px; color:#666; margin-bottom:10px;">
      <b>å¾®è§‚è°ƒè¯•æ¨¡å¼ï¼š</b><br>
      ç‚¹å‡» "å¾®æ­¥" å¯æŸ¥çœ‹æ¯ä¸€æ¬¡è·ç¦»è®¡ç®—å’Œé˜Ÿåˆ—æ›´æ–°ã€‚<br>
      <span style="color:#d00">çº¢è‰²ID</span> = æ–°ç‚¹ target<br>
      <span style="color:#007bff">è“è‰²åœˆ</span> = å½“å‰åœ¨æ­¤ç‚¹å‘å¤–çœ‹<br>
      <span style="color:#28a745">ç»¿è‰²æ¡†</span> = å½“å‰å€™é€‰æ±  (Candidates)<br>
      <span style="color:#ffc107">æ©™è‰²çº¿</span> = æ­£åœ¨æ£€æŸ¥è¿™ä¸ªé‚»å±…
    </div>

    <div class="btns">
      <button id="btnAuto" class="primary">â–¶ è‡ªåŠ¨æ’­æ”¾</button>
      <button id="btnMicro">ğŸ‘£ å¾®æ­¥ (Micro)</button>
    </div>
    <div class="btns">
      <button id="btnSkip">â­ è·³è¿‡å½“å‰ç‚¹</button>
      <button id="btnReset">â†© é‡ç½®</button>
    </div>

    <div class="row">
      <label>Seed</label>
      <input id="rngSeed" type="number" value="42" />
    </div>
    <div class="row">
      <label>Speed</label>
      <input id="speed" type="range" min="1" max="60" value="10" />
    </div>
    
    <hr style="width:100%; border:0; border-top:1px solid #eee; margin:5px 0" />
    
    <div class="row">
      <label>N (ç‚¹æ•°)</label> <input id="nPoints" type="number" value="20" />
    </div>
    <div class="row">
      <label>M (è¿æ¥)</label> <input id="mDegree" type="number" value="3" />
    </div>
    <div class="row">
      <label>ef (æœç´¢)</label> <input id="efc" type="number" value="8" />
    </div>
    <div class="row">
      <label>mL (å±‚)</label> <input id="mL" type="number" value="0.9" step="0.1" />
    </div>

    <div id="statePanel">
      <div><b>Current Action:</b></div>
      <div id="statusText" style="color:#666; margin-bottom:6px;">Ready.</div>
      <div id="queueText"></div>
    </div>
  </div>

  <div id="wrap">
    <svg id="cv" xmlns="http://www.w3.org/2000/svg"></svg>
    <div id="overlayInfo">
      <div><b>å…¨å±€çŠ¶æ€</b></div>
      <div id="hud-main">Initializing...</div>
    </div>
  </div>

<script>
/* =========================
   Math & Random
========================= */
function mulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}

/* =========================
   HNSW Nodes & Logic (Generator Version)
========================= */
class Node {
  constructor(id, x, y, level) {
    this.id = id; this.x = x; this.y = y; this.level = level;
    this.edges = new Map(); // layer -> Set(ids)
  }
  neighbors(l) {
    if (!this.edges.has(l)) this.edges.set(l, new Set());
    return this.edges.get(l);
  }
}

class HNSW {
  constructor({M, efC, mL, rng}) {
    this.M = M; this.efC = efC; this.mL = mL; this.rng = rng;
    this.nodes = [];
    this.entry = null;
    this.maxLevel = -1;
  }

  dist(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
  }

  randomLevel() {
    const u = Math.max(1e-9, this.rng());
    return Math.floor(-Math.log(u) * this.mL);
  }

  /* æ ¸å¿ƒä¿®æ”¹ï¼šå°†æ’å…¥è¿‡ç¨‹æ”¹ä¸º Generator */
  *insertGenerator(x, y, id) {
    const level = this.randomLevel();
    const q = new Node(id, x, y, level);
    this.nodes.push(q);

    // çŠ¶æ€å¯¹è±¡ï¼šä¼ ç»™ UI æ¸²æŸ“ç”¨
    let state = {
      phase: 'INIT',
      target: q,
      currEntry: null,
      layer: -1,
      focusNode: null,
      checkNode: null,
      candidates: [], // {id, dist}
      results: [],    // {id, dist} (W)
      msg: `New Point #${id} (Lv ${level}) created.`
    };
    yield {...state};

    if (this.entry === null) {
      this.entry = id;
      this.maxLevel = level;
      state.phase = 'DONE';
      state.msg = 'First node becomes entry.';
      yield {...state};
      return;
    }

    let curEntry = this.entry;
    state.currEntry = curEntry;

    // 1. Descent Phase (Greedy)
    for (let l = this.maxLevel; l > level; l--) {
      state.phase = 'DESCENT';
      state.layer = l;
      state.msg = `Descending Layer ${l}...`;
      yield {...state};

      // Greedy Search Logic inline
      let cur = curEntry;
      while(true) {
        state.focusNode = cur;
        state.msg = `Layer ${l}: At #${cur}, looking for closer neighbors...`;
        yield {...state};

        let best = cur;
        let bestDist = this.dist(q, this.nodes[cur]);
        
        const nbs = [...this.nodes[cur].neighbors(l)];
        for (const nb of nbs) {
          state.checkNode = nb;
          const d = this.dist(q, this.nodes[nb]);
          yield {...state, msg: `Checking #${cur} -> #${nb} (d=${d.toFixed(3)})`};
          
          if (d < bestDist) {
            bestDist = d;
            best = nb;
          }
        }
        state.checkNode = null;

        if (best !== cur) {
          // Found closer
          state.msg = `Found closer: #${best} (d=${bestDist.toFixed(3)}). Moving.`;
          cur = best;
          // draw arrow logic handled by visualizer trace
          yield {...state}; 
        } else {
          state.msg = `Local minimum at #${cur}. Descending.`;
          yield {...state};
          break;
        }
      }
      curEntry = cur;
      state.currEntry = curEntry;
    }

    // 2. Construction Phase (EF Search)
    const upper = Math.min(level, this.maxLevel);
    for (let l = upper; l >= 0; l--) {
      state.phase = 'CONSTRUCTION';
      state.layer = l;
      state.msg = `Building at Layer ${l}. Entry: #${curEntry}`;
      yield {...state};

      // --- efSearch Logic with Yields ---
      const visited = new Set([curEntry]);
      // C: min-heap candidates (we just sort array)
      let candidates = [{id: curEntry, d: this.dist(q, this.nodes[curEntry])}];
      // W: max-heap results (keep ef best)
      let results = [{id: curEntry, d: candidates[0].d}];
      
      state.candidates = [...candidates];
      state.results = [...results];

      while (candidates.length > 0) {
        // Pop closest candidate
        candidates.sort((a,b) => a.d - b.d);
        const c = candidates.shift();
        
        state.focusNode = c.id;
        state.candidates = [...candidates]; // update UI
        
        // Results sorted by distance
        results.sort((a,b) => a.d - b.d);
        const worst = results[results.length - 1];

        // Stop condition
        if (c.d > worst.d && results.length >= this.efC) {
          state.msg = `Stop: Candidate #${c.id} (d=${c.d.toFixed(3)}) is worse than worst result #${worst.id} (d=${worst.d.toFixed(3)}).`;
          yield {...state};
          break;
        }

        state.msg = `Expanding candidate #${c.id} (d=${c.d.toFixed(3)})...`;
        yield {...state};

        const cNode = this.nodes[c.id];
        for (const nb of cNode.neighbors(l)) {
          if (visited.has(nb)) continue;
          visited.add(nb);

          const dist = this.dist(q, this.nodes[nb]);
          state.checkNode = nb;
          
          results.sort((a,b) => a.d - b.d);
          const currentWorst = results[results.length - 1];

          let action = "";
          // Check if we should add to results
          if (results.length < this.efC || dist < currentWorst.d) {
             candidates.push({id: nb, d: dist});
             results.push({id: nb, d: dist});
             results.sort((a,b) => a.d - b.d);
             if (results.length > this.efC) results.pop(); // Keep only ef
             action = "ADDED to W";
          } else {
             action = "REJECTED (too far)";
          }

          state.candidates = [...candidates];
          state.results = [...results];
          state.msg = `Check #${nb}: d=${dist.toFixed(3)}. ${action}`;
          yield {...state};
        }
        state.checkNode = null;
      }
      // --- End efSearch ---

      // Connect neighbors
      const neighbors = results.slice(0, this.M); // M closest
      state.phase = 'CONNECT';
      state.msg = `Connecting #${id} to ${neighbors.length} neighbors in Layer ${l}.`;
      yield {...state};

      for (const res of neighbors) {
        const nb = res.id;
        this.nodes[id].neighbors(l).add(nb);
        this.nodes[nb].neighbors(l).add(id);
        
        // Prune neighbor's connections
        this.pruneToM(nb, l);
      }
      this.pruneToM(id, l);

      if (neighbors.length > 0) curEntry = neighbors[0].id;
    }

    // Update global entry
    if (level > this.maxLevel) {
      this.maxLevel = level;
      this.entry = id;
    }

    state.phase = 'DONE';
    state.msg = `Insertion of #${id} complete.`;
    state.focusNode = null;
    state.checkNode = null;
    state.candidates = [];
    state.results = [];
    yield {...state};
  }

  pruneToM(nodeId, l) {
    const n = this.nodes[nodeId];
    const nbs = [...n.neighbors(l)];
    if (nbs.length <= this.M) return;
    // Heuristic: Keep closest
    nbs.sort((a,b) => this.dist(n, this.nodes[a]) - this.dist(n, this.nodes[b]));
    const keep = new Set(nbs.slice(0, this.M));
    n.edges.set(l, keep);
  }
}

/* =========================
   App & Render Logic
========================= */
const cv = document.getElementById("cv");
const statusText = document.getElementById("statusText");
const queueText = document.getElementById("queueText");
const hudMain = document.getElementById("hud-main");

let hnsw = null;
let allPts = [];
let pointIndex = 0;
let generator = null; // Current point insertion generator
let currentState = null; // Last yielded state
let timer = null;
let rng = null;

// Settings
const COLORS = ["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b"];

function init() {
  const seed = +document.getElementById("rngSeed").value || 42;
  const N = +document.getElementById("nPoints").value;
  const M = +document.getElementById("mDegree").value;
  const efC = +document.getElementById("efc").value;
  const mL = +document.getElementById("mL").value;

  rng = mulberry32(seed);
  
  // Generate points
  allPts = [];
  for(let i=0; i<N; i++) {
     allPts.push({ x: rng()*0.86+0.07, y: rng()*0.86+0.07 });
  }

  hnsw = new HNSW({M, efC, mL, rng});
  pointIndex = 0;
  generator = null;
  currentState = null;
  
  stopAuto();
  render();
}

function nextMicroStep() {
  if (pointIndex >= allPts.length && !generator) return;

  // If no active generator, start one for the next point
  if (!generator) {
    const p = allPts[pointIndex];
    generator = hnsw.insertGenerator(p.x, p.y, pointIndex);
  }

  const res = generator.next();
  
  if (res.done) {
    // Current point finished
    generator = null;
    pointIndex++;
    currentState = null;
    render();
    if (pointIndex < allPts.length && timer) {
      // If Auto playing, continue immediately
    } else {
      stopAuto(); // Stop if manual stepping finished a point
    }
    return;
  }

  currentState = res.value;
  updateUI();
  render();
}

function skipCurrentPoint() {
  if (pointIndex >= allPts.length) return;
  // If generator exists, exhaust it
  if (generator) {
    let res = generator.next();
    while(!res.done) res = generator.next();
    generator = null;
    pointIndex++;
  } else {
    // Run full insert instantly
    const p = allPts[pointIndex];
    const gen = hnsw.insertGenerator(p.x, p.y, pointIndex);
    let res = gen.next();
    while(!res.done) res = gen.next();
    pointIndex++;
  }
  currentState = null;
  render();
}

function startAuto() {
  if (timer) return;
  const speed = +document.getElementById("speed").value;
  const delay = Math.max(10, 1000 / speed);
  
  document.getElementById("btnAuto").textContent = "â¸ æš‚åœ";
  document.getElementById("btnAuto").onclick = stopAuto;

  timer = setInterval(() => {
    if (pointIndex >= allPts.length && !generator) {
      stopAuto();
      return;
    }
    nextMicroStep();
  }, delay);
}

function stopAuto() {
  if (timer) clearInterval(timer);
  timer = null;
  document.getElementById("btnAuto").textContent = "â–¶ è‡ªåŠ¨æ’­æ”¾";
  document.getElementById("btnAuto").onclick = startAuto;
}

function updateUI() {
  if (!currentState) {
    statusText.innerText = "Ready.";
    queueText.innerHTML = "";
    return;
  }
  statusText.innerText = currentState.msg;
  
  // Update Candidates & Results Queue Visualization
  let html = "";
  if (currentState.candidates.length > 0 || currentState.results.length > 0) {
    html += `<div style="margin-top:4px; border-top:1px solid #ddd; padding-top:4px;">`;
    html += `<div><span class="tag cand">Cands (To visit)</span></div>`;
    html += currentState.candidates.map(c => 
      `<span style="margin-right:6px; opacity:0.8">#${c.id}<small>(${c.d.toFixed(2)})</small></span>`
    ).join("");
    
    html += `<div style="margin-top:4px;"><span class="tag check">W (Best ef)</span></div>`;
    html += currentState.results.map(r => 
      `<span style="margin-right:6px; font-weight:bold;">#${r.id}<small>(${r.d.toFixed(2)})</small></span>`
    ).join("");
    html += `</div>`;
  }
  queueText.innerHTML = html;
}

/* =========================
   Rendering
========================= */
function resize() {
  const r = cv.getBoundingClientRect();
  cv.setAttribute('viewBox', `0 0 ${r.width} ${r.height}`);
  cv.setAttribute('width', r.width);
  cv.setAttribute('height', r.height);
}
window.addEventListener("resize", () => { resize(); render(); });

function toXY(node, layer, maxL, W, H) {
  // Same logic as before: square aspect ratio
  const layers = Math.max(1, maxL + 1);
  const bandH = (H - 60) / layers;
  const size = Math.min(W - 40, bandH - 20);
  const offX = 20 + (W - 40 - size) / 2;
  const layerTop = 40 + (maxL - layer) * bandH;
  const offY = layerTop + (bandH - size) / 2 + 10;
  
  return {
    x: offX + node.x * size,
    y: offY + node.y * size
  };
}

function render() {
  resize();
  const W = parseFloat(cv.getAttribute('width'));
  const H = parseFloat(cv.getAttribute('height'));

  // Clear SVG
  cv.innerHTML = '';

  const maxL = Math.max(0, hnsw.maxLevel, currentState ? (currentState.target.level > hnsw.maxLevel ? currentState.target.level : 0) : 0);

  // 1. Background Layers
  const layers = Math.max(1, maxL + 1);
  const bandH = (H - 60) / layers;

  for (let l=maxL; l>=0; l--) {
    const y = 40 + (maxL - l)*bandH;

    // Background rect
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('x', 0);
    rect.setAttribute('y', y);
    rect.setAttribute('width', W);
    rect.setAttribute('height', bandH);
    rect.setAttribute('fill', l%2===0 ? "rgba(0,0,0,0.02)" : "rgba(0,0,0,0)");
    cv.appendChild(rect);

    // Layer label
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', 10);
    text.setAttribute('y', y+16);
    text.setAttribute('fill', '#aaa');
    text.setAttribute('font-family', 'monospace');
    text.setAttribute('font-size', '12px');
    text.setAttribute('font-weight', 'bold');
    text.textContent = `Layer ${l}`;
    cv.appendChild(text);
  }

  // 2. Existing Edges
  for (let l=maxL; l>=0; l--) {
    const c = COLORS[l % COLORS.length];

    for (const n of hnsw.nodes) {
      if (n.level < l) continue;
      const p1 = toXY(n, l, maxL, W, H);
      for (const nb of n.neighbors(l)) {
        if (nb < n.id) continue; // draw once
        const n2 = hnsw.nodes[nb];
        const p2 = toXY(n2, l, maxL, W, H);

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', p1.x);
        line.setAttribute('y1', p1.y);
        line.setAttribute('x2', p2.x);
        line.setAttribute('y2', p2.y);
        line.setAttribute('stroke', c + '44');
        line.setAttribute('stroke-width', 1);
        cv.appendChild(line);
      }
    }
  }

  // 3. Dynamic State Visualization (The "Microscope")
  if (currentState) {
    const l = currentState.layer;
    if (l >= 0) { // Only highlight if we are in a specific layer
      // Target Node (Red)
      const tNode = currentState.target;
      const tP = toXY(tNode, l, maxL, W, H); // Project target to current layer

      // Highlight Candidates (Green Boxes)
      if (currentState.candidates) {
        for (const c of currentState.candidates) {
          const n = hnsw.nodes[c.id];
          const p = toXY(n, l, maxL, W, H);

          const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          rect.setAttribute('x', p.x-6);
          rect.setAttribute('y', p.y-6);
          rect.setAttribute('width', 12);
          rect.setAttribute('height', 12);
          rect.setAttribute('fill', 'none');
          rect.setAttribute('stroke', '#28a745');
          rect.setAttribute('stroke-width', 2);
          cv.appendChild(rect);
        }
      }

      // Highlight Results W (Solid dots overlay)
      if (currentState.results) {
        for (const r of currentState.results) {
          const n = hnsw.nodes[r.id];
          const p = toXY(n, l, maxL, W, H);

          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', p.x);
          circle.setAttribute('cy', p.y);
          circle.setAttribute('r', 2);
          circle.setAttribute('fill', '#28a745');
          cv.appendChild(circle);
        }
      }

      // Focus Node (Blue Ring - "Eye")
      if (currentState.focusNode !== null) {
        let fid = (typeof currentState.focusNode === 'object') ? currentState.focusNode.id : currentState.focusNode;
        const fn = hnsw.nodes[fid];
        const fp = toXY(fn, l, maxL, W, H);

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', fp.x);
        circle.setAttribute('cy', fp.y);
        circle.setAttribute('r', 10);
        circle.setAttribute('fill', 'none');
        circle.setAttribute('stroke', '#007bff');
        circle.setAttribute('stroke-width', 2);
        cv.appendChild(circle);

        // Connect Eye to Target (Visual distance)
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', fp.x);
        line.setAttribute('y1', fp.y);
        line.setAttribute('x2', tP.x);
        line.setAttribute('y2', tP.y);
        line.setAttribute('stroke', '#007bff');
        line.setAttribute('stroke-width', 1);
        line.setAttribute('stroke-dasharray', '2,2');
        cv.appendChild(line);
      }

      // Check Node (Orange Line - "Checking")
      if (currentState.checkNode !== null) {
        const cn = hnsw.nodes[currentState.checkNode];
        const cp = toXY(cn, l, maxL, W, H);

        let fid = (typeof currentState.focusNode === 'object') ? currentState.focusNode.id : currentState.focusNode;
        const fn = hnsw.nodes[fid];
        const fp = toXY(fn, l, maxL, W, H);

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', fp.x);
        line.setAttribute('y1', fp.y);
        line.setAttribute('x2', cp.x);
        line.setAttribute('y2', cp.y);
        line.setAttribute('stroke', '#ffc107');
        line.setAttribute('stroke-width', 3);
        cv.appendChild(line);
      }

      // Draw Target Ghost on this layer
      const targetCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      targetCircle.setAttribute('cx', tP.x);
      targetCircle.setAttribute('cy', tP.y);
      targetCircle.setAttribute('r', 4);
      targetCircle.setAttribute('fill', '#d00');
      cv.appendChild(targetCircle);

      const targetText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      targetText.setAttribute('x', tP.x+6);
      targetText.setAttribute('y', tP.y);
      targetText.setAttribute('fill', '#d00');
      targetText.setAttribute('font-family', 'monospace');
      targetText.setAttribute('font-size', '10px');
      targetText.textContent = 'T';
      cv.appendChild(targetText);
    }
  }

  // 4. Draw Nodes
  for (let l=maxL; l>=0; l--) {
    const c = COLORS[l % COLORS.length];
    for (const n of hnsw.nodes) {
      if (n.level < l) continue;
      const p = toXY(n, l, maxL, W, H);

      // Node circle
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', p.x);
      circle.setAttribute('cy', p.y);
      circle.setAttribute('r', 3);
      circle.setAttribute('fill', c);
      cv.appendChild(circle);

      // Label
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', p.x-4);
      text.setAttribute('y', p.y-5);
      text.setAttribute('fill', '#666');
      text.setAttribute('font-family', 'monospace');
      text.setAttribute('font-size', '10px');
      text.textContent = n.id;
      cv.appendChild(text);
    }
  }

  // HUD
  hudMain.innerHTML = `Inserted: ${pointIndex}/${allPts.length}<br>Entry: #${hnsw.entry}`;
}

// Bind Events
document.getElementById("btnMicro").onclick = nextMicroStep;
document.getElementById("btnSkip").onclick = skipCurrentPoint;
document.getElementById("btnReset").onclick = init;
document.getElementById("speed").onchange = () => { if(timer) { stopAuto(); startAuto(); } };
document.getElementById("rngSeed").onchange = init;
["nPoints","mDegree","efc","mL"].forEach(id=>document.getElementById(id).onchange=init);

// Start
init();
</script>
</body>
</html>