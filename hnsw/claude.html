<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HNSWç®—æ³•å¯è§†åŒ– - åŠ¨æ€ç”Ÿæˆè¿‡ç¨‹</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
            background: #f7fafc;
            padding: 20px;
            border-radius: 10px;
        }
        button {
            padding: 10px 20px;
            background: #4299e1;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        button:hover {
            background: #3182ce;
            transform: translateY(-2px);
        }
        button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }
        .canvas-container {
            position: relative;
            background: #fafbfc;
            border-radius: 10px;
            padding: 20px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
        }
        canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
        }
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
            padding: 20px;
            background: #f7fafc;
            border-radius: 10px;
        }
        .info-item {
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #4299e1;
        }
        .info-item h3 {
            margin: 0 0 10px 0;
            color: #2d3748;
            font-size: 14px;
        }
        .info-item p {
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            color: #4a5568;
        }
        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 20px;
            padding: 15px;
            background: #edf2f7;
            border-radius: 8px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            width: 150px;
        }
        .layer-info {
            margin-left: auto;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .distance-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ HNSW (Hierarchical Navigable Small World) ç®—æ³•å¯è§†åŒ–</h1>

        <div class="controls">
            <button id="startBtn" onclick="startVisualization()">å¼€å§‹ç”Ÿæˆ</button>
            <button id="pauseBtn" onclick="pauseVisualization()" disabled>æš‚åœ</button>
            <button id="resetBtn" onclick="resetVisualization()">é‡ç½®</button>
            <button id="stepBtn" onclick="stepVisualization()">å•æ­¥æ‰§è¡Œ</button>

            <div class="speed-control">
                <label for="speed">åŠ¨ç”»é€Ÿåº¦:</label>
                <input type="range" id="speed" min="100" max="2000" value="1000" step="100">
                <span id="speedValue">1000ms</span>
            </div>

            <div class="layer-info">
                <label>
                    <input type="checkbox" id="showDistances" checked> æ˜¾ç¤ºè·ç¦»
                </label>
                <label>
                    <input type="checkbox" id="showLabels" checked> æ˜¾ç¤ºèŠ‚ç‚¹æ ‡ç­¾
                </label>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas" width="1000" height="600"></canvas>
            <div class="distance-tooltip" id="tooltip"></div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #FF6B6B;"></div>
                <span>å±‚çº§ 0ï¼ˆåŸºç¡€å±‚ï¼‰</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4ECDC4;"></div>
                <span>å±‚çº§ 1</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #45B7D1;"></div>
                <span>å±‚çº§ 2</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #96CEB4;"></div>
                <span>å±‚çº§ 3+</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFD93D;"></div>
                <span>å½“å‰æ’å…¥èŠ‚ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6C5CE7;"></div>
                <span>æ­£åœ¨å»ºç«‹è¿æ¥</span>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-item">
                <h3>æ€»èŠ‚ç‚¹æ•°</h3>
                <p id="nodeCount">0</p>
            </div>
            <div class="info-item">
                <h3>æ€»è¿æ¥æ•°</h3>
                <p id="edgeCount">0</p>
            </div>
            <div class="info-item">
                <h3>æœ€é«˜å±‚çº§</h3>
                <p id="maxLayer">0</p>
            </div>
            <div class="info-item">
                <h3>å½“å‰æ“ä½œ</h3>
                <p id="currentOp">ç­‰å¾…å¼€å§‹...</p>
            </div>
            <div class="info-item">
                <h3>Må‚æ•°(æœ€å¤§è¿æ¥æ•°)</h3>
                <p id="mParam">16</p>
            </div>
            <div class="info-item">
                <h3>mLå‚æ•°(å±‚çº§æ¦‚ç‡)</h3>
                <p id="mlParam">1/ln(2)</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');

        // HNSWå‚æ•°
        const M = 16;  // æœ€å¤§è¿æ¥æ•°
        const maxM = M;
        const maxM0 = M * 2;  // ç¬¬0å±‚çš„æœ€å¤§è¿æ¥æ•°
        const mL = 1.0 / Math.log(2.0);  // å±‚çº§åˆ†é…æ¦‚ç‡å‚æ•°
        const seed = 0;

        // å¯è§†åŒ–å‚æ•°
        let nodes = [];
        let edges = [];
        let isRunning = false;
        let animationSpeed = 1000;
        let currentNodeIndex = 0;
        let graph = {}; // åˆ†å±‚å›¾ç»“æ„

        // é¢œè‰²é…ç½®
        const layerColors = [
            '#FF6B6B',  // å±‚çº§0 - çº¢è‰²
            '#4ECDC4',  // å±‚çº§1 - é’è‰²
            '#45B7D1',  // å±‚çº§2 - è“è‰²
            '#96CEB4',  // å±‚çº§3+ - ç»¿è‰²
        ];

        // é€Ÿåº¦æ§åˆ¶
        document.getElementById('speed').addEventListener('input', (e) => {
            animationSpeed = parseInt(e.value);
            document.getElementById('speedValue').textContent = animationSpeed + 'ms';
        });

        // ç”ŸæˆéšæœºäºŒç»´ç‚¹
        function generateRandomPoint(id) {
            return {
                id: id,
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * (canvas.height - 100) + 50,
                layer: selectLayer(),
                connections: {},
                highlighted: false
            };
        }

        // é€‰æ‹©èŠ‚ç‚¹å±‚çº§ï¼ˆä½¿ç”¨æŒ‡æ•°è¡°å‡åˆ†å¸ƒï¼‰
        function selectLayer() {
            const level = Math.floor(-Math.log(Math.random()) * mL);
            return level;
        }

        // è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»
        function distance(node1, node2) {
            const dx = node1.x - node2.x;
            const dy = node1.y - node2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // åˆå§‹åŒ–HNSWç»“æ„
        function initHNSW() {
            nodes = [];
            edges = [];
            graph = {};
            currentNodeIndex = 0;

            // ç”Ÿæˆé¢„å®šä¹‰çš„èŠ‚ç‚¹ï¼ˆä½†è¿˜æœªæ’å…¥åˆ°å›¾ä¸­ï¼‰
            for (let i = 0; i < 20; i++) {
                const node = generateRandomPoint(i);
                nodes.push(node);
            }

            updateInfo();
        }

        // æ’å…¥èŠ‚ç‚¹åˆ°HNSW
        async function insertNode(nodeIndex) {
            if (nodeIndex >= nodes.length) return;

            const newNode = nodes[nodeIndex];
            newNode.highlighted = true;

            // åˆå§‹åŒ–è¯¥èŠ‚ç‚¹åœ¨å„å±‚çš„è¿æ¥
            for (let lc = 0; lc <= newNode.layer; lc++) {
                if (!graph[lc]) graph[lc] = {};
                graph[lc][newNode.id] = new Set();
                newNode.connections[lc] = new Set();
            }

            document.getElementById('currentOp').textContent = `æ’å…¥èŠ‚ç‚¹ ${newNode.id} (å±‚çº§ ${newNode.layer})`;

            if (nodeIndex === 0) {
                // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›´æ¥ä½œä¸ºå…¥å£ç‚¹
                draw();
                await sleep(animationSpeed);
            } else {
                // æŸ¥æ‰¾æœ€è¿‘é‚»å¹¶å»ºç«‹è¿æ¥
                await findAndConnect(newNode, nodeIndex);
            }

            newNode.highlighted = false;
            updateInfo();
        }

        // æŸ¥æ‰¾æœ€è¿‘é‚»å¹¶å»ºç«‹è¿æ¥
        async function findAndConnect(newNode, nodeIndex) {
            const W = new Set();

            // ä»æœ€é«˜å±‚å¼€å§‹æœç´¢
            let entryPoint = nodes[0]; // ä½¿ç”¨ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºå…¥å£ç‚¹

            for (let lc = newNode.layer; lc >= 0; lc--) {
                const candidates = searchLayer(newNode, entryPoint, 1, lc, nodeIndex);
                const m = lc === 0 ? maxM0 : maxM;

                // è·å–Mä¸ªæœ€è¿‘é‚»
                const neighbors = getMNearest(newNode, candidates, m, nodeIndex, lc);

                // å»ºç«‹è¿æ¥
                for (const neighbor of neighbors) {
                    await connectNodes(newNode, neighbor, lc);
                }

                // ä¿®å‰ªé‚»å±…çš„è¿æ¥ï¼ˆå¦‚æœè¶…è¿‡Mï¼‰
                for (const neighbor of neighbors) {
                    await pruneConnections(neighbor, lc, lc === 0 ? maxM0 : maxM);
                }
            }
        }

        // åœ¨æŒ‡å®šå±‚æœç´¢æœ€è¿‘é‚»
        function searchLayer(target, entryPoint, ef, layer, maxIndex) {
            const visited = new Set();
            const candidates = [];
            const w = [];

            // åªè€ƒè™‘å·²æ’å…¥çš„èŠ‚ç‚¹
            for (let i = 0; i < maxIndex; i++) {
                if (nodes[i].layer >= layer) {
                    candidates.push(nodes[i]);
                }
            }

            // æŒ‰è·ç¦»æ’åº
            candidates.sort((a, b) => distance(target, a) - distance(target, b));

            return candidates.slice(0, ef);
        }

        // è·å–Mä¸ªæœ€è¿‘é‚»
        function getMNearest(target, candidates, m, maxIndex, layer) {
            // è¿‡æ»¤å‡ºåœ¨å½“å‰å±‚å­˜åœ¨çš„èŠ‚ç‚¹
            const validCandidates = candidates.filter(c =>
                c.id < maxIndex && c.layer >= layer && c.id !== target.id
            );

            // æŒ‰è·ç¦»æ’åºå¹¶è¿”å›å‰Mä¸ª
            validCandidates.sort((a, b) => distance(target, a) - distance(target, b));
            return validCandidates.slice(0, m);
        }

        // è¿æ¥ä¸¤ä¸ªèŠ‚ç‚¹
        async function connectNodes(node1, node2, layer) {
            if (node1.id === node2.id) return;

            // æ·»åŠ åŒå‘è¿æ¥
            if (!node1.connections[layer]) node1.connections[layer] = new Set();
            if (!node2.connections[layer]) node2.connections[layer] = new Set();

            node1.connections[layer].add(node2.id);
            node2.connections[layer].add(node1.id);

            // æ·»åŠ è¾¹ç”¨äºå¯è§†åŒ–
            const edgeId = `${Math.min(node1.id, node2.id)}-${Math.max(node1.id, node2.id)}-${layer}`;
            if (!edges.find(e => e.id === edgeId)) {
                const newEdge = {
                    id: edgeId,
                    source: node1,
                    target: node2,
                    layer: layer,
                    distance: distance(node1, node2),
                    highlighted: true
                };
                edges.push(newEdge);

                draw();
                await sleep(animationSpeed / 2);
                newEdge.highlighted = false;
            }
        }

        // ä¿®å‰ªè¿æ¥
        async function pruneConnections(node, layer, maxConnections) {
            if (!node.connections[layer]) return;

            const connections = Array.from(node.connections[layer]);
            if (connections.length <= maxConnections) return;

            // è·å–æ‰€æœ‰è¿æ¥çš„èŠ‚ç‚¹å¹¶æŒ‰è·ç¦»æ’åº
            const connectedNodes = connections.map(id => nodes[id]).filter(n => n);
            connectedNodes.sort((a, b) => distance(node, a) - distance(node, b));

            // ä¿ç•™æœ€è¿‘çš„maxConnectionsä¸ªè¿æ¥
            const keepNodes = connectedNodes.slice(0, maxConnections);
            const keepIds = new Set(keepNodes.map(n => n.id));

            // åˆ é™¤å¤šä½™çš„è¿æ¥
            for (const id of connections) {
                if (!keepIds.has(id)) {
                    node.connections[layer].delete(id);
                    nodes[id].connections[layer].delete(node.id);

                    // åˆ é™¤è¾¹
                    const edgeId = `${Math.min(node.id, id)}-${Math.max(node.id, id)}-${layer}`;
                    edges = edges.filter(e => e.id !== edgeId);
                }
            }
        }

        // ç»˜åˆ¶å‡½æ•°
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const showDistances = document.getElementById('showDistances').checked;
            const showLabels = document.getElementById('showLabels').checked;

            // ç»˜åˆ¶è¾¹ï¼ˆè¿æ¥ï¼‰
            edges.forEach(edge => {
                ctx.beginPath();
                ctx.moveTo(edge.source.x, edge.source.y);
                ctx.lineTo(edge.target.x, edge.target.y);

                // æ ¹æ®å±‚çº§è®¾ç½®è¾¹çš„æ ·å¼
                if (edge.highlighted) {
                    ctx.strokeStyle = '#6C5CE7';
                    ctx.lineWidth = 3;
                } else {
                    const alpha = 0.3 + (edge.layer * 0.2);
                    ctx.strokeStyle = `rgba(100, 100, 100, ${Math.min(alpha, 0.8)})`;
                    ctx.lineWidth = 1 + edge.layer * 0.5;
                }

                ctx.stroke();

                // æ˜¾ç¤ºè·ç¦»
                if (showDistances && !edge.highlighted) {
                    const midX = (edge.source.x + edge.target.x) / 2;
                    const midY = (edge.source.y + edge.target.y) / 2;

                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.font = '10px Arial';
                    ctx.fillText(Math.round(edge.distance), midX, midY);
                    ctx.restore();
                }
            });

            // ç»˜åˆ¶èŠ‚ç‚¹
            nodes.forEach((node, index) => {
                if (index >= currentNodeIndex && !isRunning) return;

                // èŠ‚ç‚¹å¤§å°æ ¹æ®å±‚çº§å˜åŒ–
                const radius = 8 + node.layer * 3;

                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI);

                // è®¾ç½®èŠ‚ç‚¹é¢œè‰²
                if (node.highlighted) {
                    ctx.fillStyle = '#FFD93D';
                    ctx.strokeStyle = '#F39C12';
                    ctx.lineWidth = 3;
                } else {
                    ctx.fillStyle = layerColors[Math.min(node.layer, 3)];
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                }

                ctx.fill();
                ctx.stroke();

                // æ˜¾ç¤ºèŠ‚ç‚¹æ ‡ç­¾
                if (showLabels) {
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.id, node.x, node.y);
                }

                // æ˜¾ç¤ºå±‚çº§
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.fillText(`L${node.layer}`, node.x, node.y + radius + 12);
            });
        }

        // æ›´æ–°ä¿¡æ¯é¢æ¿
        function updateInfo() {
            document.getElementById('nodeCount').textContent = currentNodeIndex;
            document.getElementById('edgeCount').textContent = edges.length;

            const maxLayer = Math.max(0, ...nodes.slice(0, currentNodeIndex).map(n => n.layer));
            document.getElementById('maxLayer').textContent = maxLayer;
        }

        // è¾…åŠ©å‡½æ•°ï¼šå»¶è¿Ÿ
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // æ§åˆ¶å‡½æ•°
        async function startVisualization() {
            if (isRunning) return;

            isRunning = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('stepBtn').disabled = true;

            while (currentNodeIndex < nodes.length && isRunning) {
                await insertNode(currentNodeIndex);
                currentNodeIndex++;

                if (!isRunning) break;
            }

            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('stepBtn').disabled = false;

            if (currentNodeIndex >= nodes.length) {
                document.getElementById('currentOp').textContent = 'ç”Ÿæˆå®Œæˆï¼';
            }
        }

        function pauseVisualization() {
            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('currentOp').textContent = 'å·²æš‚åœ';
        }

        function resetVisualization() {
            isRunning = false;
            currentNodeIndex = 0;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('stepBtn').disabled = false;
            initHNSW();
            draw();
        }

        async function stepVisualization() {
            if (currentNodeIndex < nodes.length) {
                document.getElementById('stepBtn').disabled = true;
                await insertNode(currentNodeIndex);
                currentNodeIndex++;
                document.getElementById('stepBtn').disabled = false;

                if (currentNodeIndex >= nodes.length) {
                    document.getElementById('currentOp').textContent = 'ç”Ÿæˆå®Œæˆï¼';
                }
            }
        }

        // é¼ æ ‡æ‚¬åœæ˜¾ç¤ºè·ç¦»
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            let hoveredEdge = null;
            let minDist = Infinity;

            // æ£€æŸ¥æ˜¯å¦æ‚¬åœåœ¨è¾¹ä¸Š
            edges.forEach(edge => {
                const dist = distanceToLineSegment(
                    x, y,
                    edge.source.x, edge.source.y,
                    edge.target.x, edge.target.y
                );

                if (dist < 5 && dist < minDist) {
                    minDist = dist;
                    hoveredEdge = edge;
                }
            });

            if (hoveredEdge) {
                tooltip.style.display = 'block';
                tooltip.style.left = e.clientX + 10 + 'px';
                tooltip.style.top = e.clientY - 30 + 'px';
                tooltip.textContent = `è·ç¦»: ${hoveredEdge.distance.toFixed(2)} | å±‚çº§: ${hoveredEdge.layer}`;
            } else {
                tooltip.style.display = 'none';
            }
        });

        // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) {
                param = dot / lenSq;
            }

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;

            return Math.sqrt(dx * dx + dy * dy);
        }

        // å¤é€‰æ¡†äº‹ä»¶ç›‘å¬
        document.getElementById('showDistances').addEventListener('change', draw);
        document.getElementById('showLabels').addEventListener('change', draw);

        // åˆå§‹åŒ–
        initHNSW();
        draw();
    </script>
</body>
</html>