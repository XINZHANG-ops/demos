<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HNSW 可视化 (带箭头指示)</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans SC", Arial;
      display: grid; grid-template-columns: 360px 1fr; height: 100vh;
      background: #fbfbfb;
    }
    #panel {
      padding: 14px 14px 10px; border-right: 1px solid rgba(128,128,128,.25);
      background: #fff;
      overflow: auto;
      box-shadow: 2px 0 10px rgba(0,0,0,0.02);
    }
    #panel h2 { margin: 0 0 10px; font-size: 16px; color: #333; }
    .row { display: grid; grid-template-columns: 1fr 92px; gap: 10px; align-items: center; margin: 8px 0; }
    .row label { font-size: 13px; opacity: .85; }
    .row input[type="range"] { width: 100%; accent-color: #666; }
    .row input[type="number"] { width: 92px; padding: 4px 6px; border:1px solid #ccc; border-radius:4px; }
    .btns { display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0 12px; }
    button {
      padding: 8px 12px; border-radius: 6px; border: 1px solid rgba(128,128,128,.35);
      background: #f0f0f0; cursor: pointer; font-size: 13px; color: #333;
      transition: all 0.1s;
    }
    button:hover { background: #e0e0e0; border-color: #999; }
    button:active { background: #d0d0d0; transform: translateY(1px); }
    .check { display: flex; gap: 10px; align-items: center; margin: 8px 0; font-size: 13px; color: #444; }
    .muted { opacity: .75; font-size: 12px; line-height: 1.4; margin-top: 15px; color: #666; background: #f9f9f9; padding: 8px; border-radius: 6px;}
    .legend { font-size: 12px; opacity: .9; margin-top: 10px; }
    .legend .sw { display:inline-block; width: 10px; height:10px; border-radius: 3px; margin-right: 6px; vertical-align: -1px; }
    #wrap { position: relative; background: #f4f4f4; overflow: hidden; }
    canvas { width: 100%; height: 100%; display: block; }
    #hud {
      position: absolute; left: 12px; top: 12px; padding: 10px 12px;
      border-radius: 8px; border: 1px solid rgba(0,0,0,.1);
      background: rgba(255,255,255,.9); backdrop-filter: blur(4px);
      font-size: 12px; line-height: 1.4; max-width: 520px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      color: #333;
    }
  </style>
</head>
<body>
  <div id="panel">
    <h2>HNSW 构建可视化 (箭头版)</h2>

    <div class="btns">
      <button id="btnPlay">▶ 播放</button>
      <button id="btnStep">⏭ 单步插入</button>
      <button id="btnReset">↩ 重置</button>
    </div>

    <div class="row" style="background:#eef; padding:4px 8px; border-radius:4px;">
      <label><b>随机种子 (Seed)</b></label>
      <input id="rngSeed" type="number" min="1" max="99999" value="42" />
    </div>

    <div class="row">
      <label>点数 N</label>
      <input id="nPoints" type="number" min="5" max="100" value="30" />
    </div>
    <div class="row">
      <label>M（最大连接数）</label>
      <input id="mDegree" type="number" min="2" max="20" value="4" />
    </div>
    <div class="row">
      <label>efConstruction</label>
      <input id="efc" type="number" min="4" max="80" value="12" />
    </div>
    <div class="row">
      <label>层参数 mL</label>
      <input id="mL" type="number" min="0.5" max="3.0" step="0.1" value="0.9" />
    </div>

    <div class="row">
      <label>动画速度</label>
      <input id="speed" type="range" min="0.2" max="5" step="0.1" value="1.0" />
    </div>

    <div class="check">
      <input id="showGhost" type="checkbox" checked />
      <label for="showGhost">显示上层幽灵点</label>
    </div>
    <div class="check">
      <input id="showLabels" type="checkbox" checked />
      <label for="showLabels">显示点序号 (ID)</label>
    </div>
    <div class="check">
      <input id="showBound" type="checkbox" checked />
      <label for="showBound">显示坐标边界框</label>
    </div>

    <div class="muted">
      <b>更新说明：</b><br/>
      现在所有虚线路径都添加了<span style="font-weight:bold;">箭头</span>。<br/>
      箭头指向移动方向 (From -> To)。<br/>
      可以清楚分辨是 2->3 还是 3->2。
    </div>

    <div class="legend" id="legend"></div>
  </div>

  <div id="wrap">
    <canvas id="cv"></canvas>
    <div id="hud"></div>
  </div>

<script>
/* =========================
   基础工具
========================= */
function mulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}

/* =========================
   HNSW 核心逻辑
========================= */
class Node {
  constructor(id, x, y, level) {
    this.id = id;
    this.x = x; this.y = y;
    this.level = level;
    this.edgesByLayer = new Map();
  }
  neighbors(l){
    if(!this.edgesByLayer.has(l)) this.edgesByLayer.set(l, new Set());
    return this.edgesByLayer.get(l);
  }
}

class HNSW {
  constructor({M=6, efC=18, mL=1.2, rng=Math.random}) {
    this.M = M;
    this.efC = efC;
    this.mL = mL;
    this.rng = rng;
    this.nodes = [];
    this.entry = null;
    this.maxLevel = -1;
    this.trace = null; 
  }

  dist(a, b){
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.hypot(dx, dy);
  }

  randomLevel(){
    const u = Math.max(1e-9, this.rng());
    return Math.floor(-Math.log(u) * this.mL);
  }

  greedySearchLayer(qNode, entryId, l, traceStep){
    let cur = entryId;
    let improved = true;
    const path = [cur];
    
    while(improved){
      improved = false;
      const curNode = this.nodes[cur];
      const curDist = this.dist(qNode, curNode);
      let best = cur;
      let bestDist = curDist;

      for(const nb of curNode.neighbors(l)){
        const d = this.dist(qNode, this.nodes[nb]);
        if(d < bestDist){
          bestDist = d;
          best = nb;
        }
      }
      if(best !== cur){
        cur = best;
        path.push(cur);
        improved = true;
      }
    }
    if(traceStep){
      traceStep.greedyPaths.push({layer:l, path:[...path]});
    }
    return cur;
  }

  searchLayerEF(qNode, entryId, l, ef, traceStep){
    const visited = new Set([entryId]);
    let candidates = [{id: entryId, d: this.dist(qNode, this.nodes[entryId])}];
    let results = [{id: entryId, d: candidates[0].d}];

    function sortByD(arr){ arr.sort((a,b)=>a.d-b.d); }
    sortByD(candidates);

    const expansions = [];

    while(candidates.length){
      sortByD(candidates);
      const c = candidates.shift(); 
      sortByD(results);
      const worst = results[results.length - 1];

      if(results.length >= ef && c.d > worst.d) break;

      const cNode = this.nodes[c.id];
      const exploredNeighbors = [];
      for(const nb of cNode.neighbors(l)){
        if(visited.has(nb)) continue;
        visited.add(nb);
        const d = this.dist(qNode, this.nodes[nb]);
        exploredNeighbors.push({id: nb, d});
        candidates.push({id: nb, d});
        results.push({id: nb, d});
      }
      
      sortByD(results);
      if(results.length > ef) results = results.slice(0, ef);

      expansions.push({from: c.id, explored: exploredNeighbors.map(e=>e.id)});
    }

    if(traceStep){
      traceStep.efSearch.push({layer:l, entry:entryId, results: results.map(r=>r.id), expansions});
    }
    return results.map(r => r.id);
  }

  connect(aId, bId, l){
    const a = this.nodes[aId], b = this.nodes[bId];
    a.neighbors(l).add(bId);
    b.neighbors(l).add(aId);
  }

  pruneToM(nodeId, l){
    const n = this.nodes[nodeId];
    const nbs = [...n.neighbors(l)];
    if(nbs.length <= this.M) return;
    nbs.sort((i,j)=> this.dist(n, this.nodes[i]) - this.dist(n, this.nodes[j]));
    const keep = new Set(nbs.slice(0, this.M));
    n.edgesByLayer.set(l, keep);
  }

  insertPoint(x, y){
    const stepTrace = {
      newNodeId: null,
      newNodeLevel: null,
      greedyPaths: [],    
      efSearch: [],        
      chosenNeighbors: [] 
    };

    const level = this.randomLevel();
    const id = this.nodes.length;
    const q = new Node(id, x, y, level);
    stepTrace.newNodeId = id;
    stepTrace.newNodeLevel = level;

    this.nodes.push(q);

    if(this.entry === null){
      this.entry = id;
      this.maxLevel = level;
      this.trace = stepTrace;
      return stepTrace;
    }

    let curEntry = this.entry;

    for(let l = this.maxLevel; l > level; l--){
      curEntry = this.greedySearchLayer(q, curEntry, l, stepTrace);
    }

    const upper = Math.min(level, this.maxLevel);
    for(let l = upper; l >= 0; l--){
      const candidates = this.searchLayerEF(q, curEntry, l, this.efC, stepTrace);

      candidates.sort((i,j)=> this.dist(q, this.nodes[i]) - this.dist(q, this.nodes[j]));
      const neighbors = candidates.slice(0, this.M);

      stepTrace.chosenNeighbors.push({layer:l, neighbors:[...neighbors]});

      for(const nb of neighbors){
        this.connect(id, nb, l);
        this.pruneToM(nb, l);
      }
      this.pruneToM(id, l);

      if(neighbors.length > 0) curEntry = neighbors[0];
    }

    if(level > this.maxLevel){
      this.entry = id;
      this.maxLevel = level;
    }

    this.trace = stepTrace;
    return stepTrace;
  }
}

/* =========================
   主控逻辑
========================= */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");
const hud = document.getElementById("hud");

let rngSeed = 42;
let rng = mulberry32(rngSeed);
let allPts = [];
let hnsw = null;
let inserted = 0;
let playing = false;
let lastTick = 0;
let accum = 0;

function resizeCanvas(){
  const dpr = window.devicePixelRatio || 1;
  const rect = cv.getBoundingClientRect();
  cv.width = Math.floor(rect.width * dpr);
  cv.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener("resize", () => { resizeCanvas(); render(); });

const COLORS = [
  "#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd",
  "#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"
];

function rgba(hex, a){
  const h = hex.replace("#","");
  const r = parseInt(h.slice(0,2),16);
  const g = parseInt(h.slice(2,4),16);
  const b = parseInt(h.slice(4,6),16);
  return `rgba(${r},${g},${b},${a})`;
}

function genPoints(n){
  const pts = [];
  const minD = 0.05; 
  let tries = 0;
  while(pts.length < n && tries < n*200){
    tries++;
    const x = rng()*0.86 + 0.07;
    const y = rng()*0.86 + 0.07;
    let ok = true;
    for(const p of pts){
      if(Math.hypot(x-p.x, y-p.y) < minD){ ok = false; break; }
    }
    if(ok) pts.push({x,y});
  }
  while(pts.length < n){
    pts.push({x: rng()*0.86+0.07, y: rng()*0.86+0.07});
  }
  return pts;
}

function reset(){
  // 获取用户输入的种子
  const seedInput = document.getElementById("rngSeed").value;
  rngSeed = parseInt(seedInput) || 42;
  rng = mulberry32(rngSeed);
  
  const N = +document.getElementById("nPoints").value;
  const M = +document.getElementById("mDegree").value;
  const efC = +document.getElementById("efc").value;
  const mL = +document.getElementById("mL").value;

  allPts = genPoints(N);
  hnsw = new HNSW({M, efC, mL, rng});
  inserted = 0;
  playing = false;
  document.getElementById("btnPlay").textContent = "▶ 播放";
  
  const leg = document.getElementById("legend");
  let html = `<div style="margin-top:4px;"><b>层级颜色</b></div>`;
  for(let l=4; l>=0; l--){
    const c = COLORS[l % COLORS.length];
    html += `<div><span class="sw" style="background:${c}"></span>L${l}</div>`;
  }
  leg.innerHTML = html;
  
  render();
}

function stepInsert(){
  if(inserted >= allPts.length) return;
  const p = allPts[inserted];
  hnsw.insertPoint(p.x, p.y);
  inserted++;
  render();
}

function togglePlay(){
  playing = !playing;
  document.getElementById("btnPlay").textContent = playing ? "⏸ 暂停" : "▶ 播放";
}

document.getElementById("btnReset").addEventListener("click", reset);
document.getElementById("btnStep").addEventListener("click", ()=>{ playing=false; document.getElementById("btnPlay").textContent="▶ 播放"; stepInsert(); });
document.getElementById("btnPlay").addEventListener("click", togglePlay);
document.getElementById("rngSeed").addEventListener("change", reset);
["nPoints","mDegree","efc","mL"].forEach(id=>document.getElementById(id).addEventListener("change", reset));
["showLabels","showGhost","showBound"].forEach(id=>document.getElementById(id).addEventListener("change", render));
window.addEventListener("keydown", (e)=>{
  if(e.code === "Space"){ e.preventDefault(); togglePlay(); }
  if(e.key.toLowerCase() === "r"){ reset(); }
});

function loop(ts){
  if(!lastTick) lastTick = ts;
  const dt = (ts - lastTick) / 1000;
  lastTick = ts;

  if(playing){
    const speed = +document.getElementById("speed").value;
    accum += dt * speed;
    while(accum >= 1){
      accum -= 1;
      if(inserted < allPts.length) stepInsert();
      else { playing = false; document.getElementById("btnPlay").textContent="▶ 播放"; }
    }
  }
  requestAnimationFrame(loop);
}

/* =========================
   渲染核心 (Arrow Fix)
========================= */
function render(){
  resizeCanvas();
  const W = cv.clientWidth;
  const H = cv.clientHeight;
  ctx.clearRect(0,0,W,H);

  if(!hnsw){
    ctx.fillStyle = "#666"; ctx.fillText("Initialize...", 20, 20);
    return;
  }

  const maxL = Math.max(0, hnsw.maxLevel);
  const layers = Math.max(1, maxL + 1);
  
  const topPad = 40;
  const bottomPad = 20;
  const leftPad = 20;
  const rightPad = 20;
  const bandH = (H - topPad - bottomPad) / layers;
  
  const availW = W - leftPad - rightPad;
  const availH = bandH - 25; 
  const size = Math.min(availW, availH); 
  const offsetX = leftPad + (availW - size) / 2;
  
  function toXY(p, layer){
    const layerTop = topPad + (maxL - layer) * bandH;
    const offsetY = layerTop + (bandH - size) / 2 + 10;
    return {
      x: offsetX + p.x * size,
      y: offsetY + p.y * size,
      originX: offsetX,
      originY: offsetY,
      s: size
    };
  }
  
  // 画箭头辅助函数
  function drawArrowHead(fromP, toP, color) {
    const headLen = 8;
    const dx = toP.x - fromP.x;
    const dy = toP.y - fromP.y;
    const angle = Math.atan2(dy, dx);
    const dist = Math.hypot(dx, dy);
    
    // 缩短目标点，让箭头不要插到圆心，而是停在圆的边缘
    // 假设圆半径大约 6，留一点空隙
    const gap = 8; 
    if(dist < gap) return; // 太近就不画了

    const endX = fromP.x + (dx * (dist - gap)) / dist;
    const endY = fromP.y + (dy * (dist - gap)) / dist;

    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([]); // 箭头是实线

    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  const showGhost = document.getElementById("showGhost").checked;
  const showBound = document.getElementById("showBound").checked;
  const showLabels = document.getElementById("showLabels").checked;

  // 1. 背景
  for(let l=maxL; l>=0; l--){
    const layerTop = topPad + (maxL - l) * bandH;
    ctx.fillStyle = (l%2===0) ? "rgba(0,0,0,0.03)" : "rgba(0,0,0,0)";
    ctx.fillRect(0, layerTop, W, bandH);
    ctx.fillStyle = "#555";
    ctx.font = "bold 12px sans-serif";
    ctx.fillText(`Layer ${l}`, 10, layerTop + 16);

    if(showBound){
      const t = toXY({x:0, y:0}, l);
      ctx.strokeStyle = "rgba(0,0,0,0.1)";
      ctx.setLineDash([4,4]);
      ctx.strokeRect(t.originX, t.originY, t.s, t.s);
      ctx.setLineDash([]);
    }
  }

  // 2. 边 (Structure)
  for(let l=maxL; l>=0; l--){
    const c = COLORS[l % COLORS.length];
    ctx.strokeStyle = rgba(c, 0.35); 
    ctx.lineWidth = 1.2;

    for(let i=0;i<inserted;i++){
      const ni = hnsw.nodes[i];
      if(ni.level < l) continue;
      
      for(const nb of ni.neighbors(l)){
        const nj = hnsw.nodes[nb];
        const A = toXY(ni, l), B = toXY(nj, l);
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
      }
    }
  }

  // 3. 动画 Trace (含箭头)
  const trace = hnsw.trace;
  if(trace && inserted > 0){
    // Greedy Path
    for(const gp of trace.greedyPaths){
      const l = gp.layer;
      const c = COLORS[l % COLORS.length];
      const lineColor = rgba(c, 0.9);
      
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 2;
      ctx.setLineDash([5,5]);
      
      for(let k=0;k<gp.path.length-1;k++){
        const A = toXY(hnsw.nodes[gp.path[k]], l);
        const B = toXY(hnsw.nodes[gp.path[k+1]], l);
        
        // 画虚线
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
        
        // 画实心箭头
        drawArrowHead(A, B, lineColor);
      }
      ctx.setLineDash([]);
    }
    
    // New Neighbors (Bold)
    for(const cn of trace.chosenNeighbors){
      const l = cn.layer;
      const c = COLORS[l % COLORS.length];
      ctx.strokeStyle = rgba(c, 1.0);
      ctx.lineWidth = 2.5;
      const Q = toXY(hnsw.nodes[trace.newNodeId], l);
      for(const nb of cn.neighbors){
        const N = toXY(hnsw.nodes[nb], l);
        ctx.beginPath();
        ctx.moveTo(Q.x, Q.y);
        ctx.lineTo(N.x, N.y);
        ctx.stroke();
      }
    }
  }

  // 4. 点 & 标签
  for(let l=maxL; l>=0; l--){
    const c = COLORS[l % COLORS.length];
    
    for(let i=0;i<inserted;i++){
      const n = hnsw.nodes[i];
      const inLayer = n.level >= l; 
      
      if(!inLayer && !showGhost) continue;

      const P = toXY(n, l);
      const isNewNode = (trace && i === trace.newNodeId);

      let r, fillStyle, strokeStyle, labelColor, labelFont;
      
      if(inLayer) {
        r = 5;
        if(isNewNode){
          fillStyle = "#d00"; strokeStyle = "#fff";
          labelColor = "#d00"; labelFont = "bold 12px monospace";
          r = 7;
        } else {
          fillStyle = rgba(c, 0.6); strokeStyle = rgba(c, 0.8);
          labelColor = "#333"; labelFont = "bold 10px monospace";
        }
      } else {
        r = 3; 
        fillStyle = "rgba(180,180,180,0.15)"; strokeStyle = "rgba(180,180,180,0.25)";
        if(isNewNode){
            fillStyle = "rgba(220,0,0,0.1)"; strokeStyle = "rgba(220,0,0,0.2)";
            labelColor = "rgba(220,0,0,0.5)"; labelFont = "10px monospace";
        } else {
            labelColor = "rgba(160,160,160,0.5)"; labelFont = "9px monospace";
        }
      }

      ctx.beginPath();
      ctx.arc(P.x, P.y, r, 0, Math.PI*2);
      ctx.fillStyle = fillStyle;
      ctx.fill();
      ctx.lineWidth = isNewNode && inLayer ? 2 : 1;
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();

      if(showLabels){
        ctx.fillStyle = labelColor;
        ctx.font = labelFont;
        ctx.textAlign = "center";
        ctx.fillText(String(n.id), P.x, P.y - r - 4);
      }
    }
  }

  // HUD
  const entry = hnsw.entry;
  const lastInfo = trace ? `ID #${trace.newNodeId} (Lv ${trace.newNodeLevel})` : "—";
  hud.innerHTML = `
    <div style="font-weight:600;margin-bottom:4px">状态监视器</div>
    <div>Inserted: ${inserted} / ${allPts.length}</div>
    <div>Max Level: ${hnsw.maxLevel}</div>
    <div>Global Entry: ${entry===null?"—":"#"+entry}</div>
    <div>Seed: ${rngSeed}</div>
    <hr style="border:0;border-top:1px solid #ddd;margin:6px 0"/>
    <div>Last Insert: <span style="color:#d00">${lastInfo}</span></div>
    <div style="font-size:11px;color:#888;margin-top:4px">
      虚线箭头: 搜索方向<br>
      实粗线: 最终连接<br>
    </div>
  `;
}

init();
function init(){
  reset();
  loop(0);
}
</script>
</body>
</html>